import { URLSearchParams } from "url";

import { isEmpty } from "lodash";
import Cache from "timed-cache";

import { Logger } from "../../../logger";
import {
	GetLibraryDetailsRequest,
	GetLibraryDetailsResponse,
	GetLibraryDetailsType,
	GetSecurityIssuesForEntityRequest,
	GetSecurityIssuesForEntityResponse,
	GetSecurityIssuesForEntityType,
	LibraryDetails,
	SecurityIssueSummaryResponse,
	ThirdPartyProviderConfig,
	Vulns,
} from "../../../protocol/agent.protocol.providers";
import { CodeStreamSession } from "../../../session";
import { log, lspHandler, lspProvider } from "../../../system";
import { ThirdPartyProviderBase } from "../../thirdPartyProviderBase";
import { EntityLibraries, LibraryUsage } from "./types";

const TIMEOUT = 5000;

@lspProvider("newrelic-vulnerabilities")
export class NewRelicVulnerabilitiesProvider extends ThirdPartyProviderBase {
	private dataCache: Cache<SecurityIssueSummaryResponse>;
	private filterCache: Cache<SecurityIssueSummaryResponse>;
	private libraryDetailsCache: Cache<GetLibraryDetailsResponse>;

	constructor(session: CodeStreamSession, config: ThirdPartyProviderConfig) {
		super(session, config);
		this.dataCache = new Cache({ defaultTtl: 900 * 1000 }); // 15 minutes
		this.filterCache = new Cache({ defaultTtl: 300 * 1000 }); // 5 minutes
		this.libraryDetailsCache = new Cache({ defaultTtl: 900 * 1000 }); // 15 minutes
	}

	get displayName(): string {
		return "New Relic Vulnerability Management";
	}

	get headers(): { [p: string]: string } {
		const accessToken = this.accessToken;
		if (!accessToken) {
			throw new Error(`Missing accessToken for ${this.name}`);
		}
		return {
			"Api-Key": accessToken,
			"Content-Type": "application/json",
		};
	}

	get name(): string {
		return "newrelic"; // Use existing providerInfo to get API key
	}

	get baseUrl(): string {
		return "https://nrsec-workflow-api.staging-service.newrelic.com"; // TODO not hardcode
	}

	@lspHandler(GetSecurityIssuesForEntityType)
	@log()
	async getSecurityIssuesForEntity(
		request: GetSecurityIssuesForEntityRequest
	): Promise<GetSecurityIssuesForEntityResponse> {
		const data = await this.getSecurityIssues(request);
		const { rows = 5 } = request;
		const securityIssues = rows === "all" ? data : data.slice(0, rows);
		return {
			securityIssues,
			recordCount: securityIssues.length,
			totalRecords: data.length,
		};
	}

	private async getSecurityIssues(
		request: GetSecurityIssuesForEntityRequest
	): Promise<SecurityIssueSummaryResponse> {
		let httpResponseCached: SecurityIssueSummaryResponse | undefined = this.dataCache.get("DATA");
		if (!httpResponseCached) {
			const response = await this.fetchSecurityIssues(request.entityGuid, request.accountId);
			this.dataCache.put("DATA", response);
			httpResponseCached = response;
			this.filterCache.clear();
		}
		const cachedFilter = this.filterCache.get(JSON.stringify(request));
		if (!cachedFilter) {
			if (!request.severityFilter) {
				this.filterCache.put(JSON.stringify(request), httpResponseCached);
				Logger.log(
					`getSecurityIssuesForEntity ${JSON.stringify(request)} ${
						httpResponseCached.length
					} not cached`
				);
				return httpResponseCached;
			} else {
				const filtered = httpResponseCached.filter(_ =>
					request.severityFilter?.includes(_.severity)
				);
				this.filterCache.put(JSON.stringify(request), filtered);
				Logger.log(
					`getSecurityIssuesForEntity ${JSON.stringify(request)} ${filtered.length} not cached`
				);
				return filtered;
			}
		} else {
			Logger.log(
				`getSecurityIssuesForEntity ${JSON.stringify(request)} ${cachedFilter.length} from cache`
			);
			return cachedFilter;
		}
	}

	private async fetchSecurityIssues(
		entityGuid: string,
		accountId: number
	): Promise<SecurityIssueSummaryResponse> {
		const queryString = new URLSearchParams({
			entities: `(id='${entityGuid}')`,
		}).toString();
		const path = `/v1/issues/accounts/${accountId}/?${queryString}`;
		const response = await this.get<SecurityIssueSummaryResponse>(path, undefined, {
			timeout: TIMEOUT,
		});
		return response.body;
	}

	// TODO maybe also group by CVE
	@lspHandler(GetLibraryDetailsType)
	@log()
	async getLibraryDetails(request: GetLibraryDetailsRequest): Promise<GetLibraryDetailsResponse> {
		const cached = this.libraryDetailsCache.get(JSON.stringify(request));
		if (cached) {
			Logger.log(`getLibraryDetails cached response ${cached.libraries.length} records`);
			return cached;
		}
		const { entityGuid, accountId } = request;
		const allLibraries = await this.fetchLibraries(entityGuid, accountId);
		const libraryDetails = new Array<LibraryDetails>();
		for (const library of allLibraries.libraries) {
			const libraryVulnerabilities = await this.fetchLibraryVulnerabilities(
				accountId,
				library.name,
				library.language
			);
			if (isEmpty(library.includedVersions)) {
				continue;
			}
			const version = library.includedVersions[0].version; // TODO which one to choose? Cross-reference package.json?
			// const versionStringKey = Object.keys(vulnerabilities.vulnerabilities); // keys like "3.0.4, 2.0.10"
			const vulns = libraryVulnerabilities.vulnerabilities[version];
			if (!vulns) {
				continue;
			}
			const vulnResponse = new Array<Vulns>();
			let highestScore = 0;
			for (const finding of vulns) {
				highestScore = Math.max(highestScore, finding.score);
				vulnResponse.push({
					criticality: finding.criticality,
					description: finding.description,
					issueId: finding.cve,
					remediation: finding.remediation,
					score: finding.score,
					title: finding.title,
					url: finding.url,
				});
			}

			libraryDetails.push({
				name: library.name,
				version: version,
				language: library.language,
				highestScore,
				vulns: vulnResponse,
			});
		}
		libraryDetails.sort((a, b) => b.highestScore - a.highestScore);
		const response: GetLibraryDetailsResponse = { libraries: libraryDetails };
		this.libraryDetailsCache.put(JSON.stringify(request), response);
		return response;
	}

	private async fetchLibraries(entityGuid: string, accountId: number): Promise<EntityLibraries> {
		const path = `/v1/inventory/accounts/${accountId}/entities/${entityGuid}/libraries`;
		const response = await this.get<EntityLibraries>(path, undefined, {
			timeout: TIMEOUT,
		});
		return response.body;
	}

	private async fetchLibraryVulnerabilities(
		accountId: number,
		library: string,
		language?: string
	): Promise<LibraryUsage> {
		const urlParams = new URLSearchParams({
			library,
		});
		if (language) {
			urlParams.append("language", language);
		}
		const queryString = urlParams.toString();

		const path = `/v1/inventory/accounts/${accountId}/library?${queryString}`;
		const response = await this.get<LibraryUsage>(path, undefined, {
			timeout: TIMEOUT,
		});
		return response.body;
	}
}
